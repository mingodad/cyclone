/*

DO NOT edit this file

*/
#include "list.h"
#include "regions.h"
#include "banshee.h"
#include <assert.h>
#include <stdio.h>
#include "bool.h"
#include "ufind.h"
#include <string.h>
#include "hash.h"
#include "banshee_region_persist_kinds.h"
#include "term-sort.h"
#include "setif-sort.h"
#include "term-sort.h"
#include "term-sort.h"
#include "term-sort.h"

#define ATOMIC_ 11
#define NUMELTS_ 12
#define EQ_ 13
#define GEQ_ 14

typedef gen_e ptrbnd;
typedef gen_e_list ptrbnd_list;

typedef gen_e effect;
typedef gen_e_list effect_list;

typedef gen_e zeroterm;
typedef gen_e_list zeroterm_list;

typedef gen_e intlit;
typedef gen_e_list intlit_list;

typedef gen_e intbound;
typedef gen_e_list intbound_list;


stamp ptrbnd_get_stamp(gen_e arg1);
bool ptrbnd_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(ptrbnd_list,gen_e);
ptrbnd ptrbnd_zero(void);
ptrbnd ptrbnd_one(void);
ptrbnd ptrbnd_wild(void);
ptrbnd ptrbnd_fresh(const char *name);
ptrbnd ptrbnd_constant(const char *name) ;
bool ptrbnd_is_constant(ptrbnd e,const char *name);
ptrbnd ptrbnd_ecr(ptrbnd e) ;
void ptrbnd_inclusion_ind(ptrbnd e1,ptrbnd e2) ;
void ptrbnd_cunify_ind(ptrbnd e1, ptrbnd e2) ;
void ptrbnd_unify_ind(ptrbnd e1,ptrbnd e2) ;

static struct gen_term atomic_ = {ATOMIC_,ATOMIC_};
ptrbnd atomic(void);
bool ptrbnd_is_atomic(ptrbnd arg1);
ptrbnd numelts(intbound arg1);
struct numelts_decon numelts_decon(ptrbnd arg1);
struct numelts_
{
int type;
stamp st;
intbound f0;
};
struct numelts_decon
{
intbound f0;
};
void ptrbnd_print(FILE* arg1,ptrbnd arg2);
bool ptrbnd_occurs(term_var arg1,ptrbnd arg2);
void ptrbnd_con_match(gen_e arg1,gen_e arg2);
stamp effect_get_stamp(gen_e arg1);
bool effect_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(effect_list,gen_e);
effect effect_zero(void);
effect effect_one(void);
effect effect_wild(void);
effect effect_fresh(const char *name);
effect effect_fresh_large(const char *name);
effect effect_union(effect_list exprs);
effect effect_inter(effect_list exprs);
effect effect_constant(const char *name);
bool effect_is_constant(effect e,const char *name);
effect_list effect_tlb(effect e);
void effect_inclusion_ind(effect e1,effect e2);
void effect_unify_ind(effect e1,effect e2);

void effect_print(FILE* arg1,effect arg2);
bool effect_res_proj(setif_var arg1,gen_e arg2);
void effect_con_match(gen_e arg1,gen_e arg2);
stamp zeroterm_get_stamp(gen_e arg1);
bool zeroterm_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(zeroterm_list,gen_e);
zeroterm zeroterm_zero(void);
zeroterm zeroterm_one(void);
zeroterm zeroterm_wild(void);
zeroterm zeroterm_fresh(const char *name);
zeroterm zeroterm_constant(const char *name) ;
bool zeroterm_is_constant(zeroterm e,const char *name);
zeroterm zeroterm_ecr(zeroterm e) ;
void zeroterm_inclusion_ind(zeroterm e1,zeroterm e2) ;
void zeroterm_cunify_ind(zeroterm e1, zeroterm e2) ;
void zeroterm_unify_ind(zeroterm e1,zeroterm e2) ;

void zeroterm_print(FILE* arg1,zeroterm arg2);
bool zeroterm_occurs(term_var arg1,zeroterm arg2);
void zeroterm_con_match(gen_e arg1,gen_e arg2);
stamp intlit_get_stamp(gen_e arg1);
bool intlit_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(intlit_list,gen_e);
intlit intlit_zero(void);
intlit intlit_one(void);
intlit intlit_wild(void);
intlit intlit_fresh(const char *name);
intlit intlit_constant(const char *name) ;
bool intlit_is_constant(intlit e,const char *name);
intlit intlit_ecr(intlit e) ;
void intlit_inclusion_ind(intlit e1,intlit e2) ;
void intlit_cunify_ind(intlit e1, intlit e2) ;
void intlit_unify_ind(intlit e1,intlit e2) ;

void intlit_print(FILE* arg1,intlit arg2);
bool intlit_occurs(term_var arg1,intlit arg2);
void intlit_con_match(gen_e arg1,gen_e arg2);
stamp intbound_get_stamp(gen_e arg1);
bool intbound_is_var(gen_e arg1);
DECLARE_OPAQUE_LIST(intbound_list,gen_e);
intbound intbound_zero(void);
intbound intbound_one(void);
intbound intbound_wild(void);
intbound intbound_fresh(const char *name);
intbound intbound_constant(const char *name) ;
bool intbound_is_constant(intbound e,const char *name);
intbound intbound_ecr(intbound e) ;
void intbound_inclusion_ind(intbound e1,intbound e2) ;
void intbound_cunify_ind(intbound e1, intbound e2) ;
void intbound_unify_ind(intbound e1,intbound e2) ;

intbound eq(intlit arg1);
struct eq_decon eq_decon(intbound arg1);
struct eq_
{
int type;
stamp st;
intlit f0;
};
struct eq_decon
{
intlit f0;
};
intbound geq(intlit arg1);
struct geq_decon geq_decon(intbound arg1);
struct geq_
{
int type;
stamp st;
intlit f0;
};
struct geq_decon
{
intlit f0;
};
void intbound_print(FILE* arg1,intbound arg2);
bool intbound_occurs(term_var arg1,intbound arg2);
void intbound_con_match(gen_e arg1,gen_e arg2);

stamp ptrbnd_get_stamp(gen_e arg1) 
{
return term_get_stamp((gen_e)arg1);
}

bool ptrbnd_is_var(gen_e arg1) 
{
return term_is_var((gen_e)arg1);
}

DEFINE_LIST(ptrbnd_list,gen_e);

ptrbnd ptrbnd_zero(void)
{
 return term_zero();
}

ptrbnd ptrbnd_one(void)
{
 return term_one();
}

ptrbnd ptrbnd_wild(void)
{
 return term_wild();
}

ptrbnd ptrbnd_fresh(const char *name)
{
 return term_fresh(name);
}

ptrbnd ptrbnd_fresh_small(const char *name)
{
 return term_fresh_small(name);
}

ptrbnd ptrbnd_fresh_large(const char *name)
{
 return term_fresh_large(name);
}

ptrbnd ptrbnd_constant(const char *name) 
{
 return term_constant(name);
}

bool ptrbnd_is_constant(ptrbnd e, const char *name) 
{
 if (term_is_constant(e))
return (! strcmp(name,term_get_constant_name(e)));
else return FALSE;
}

ptrbnd ptrbnd_ecr(ptrbnd e) 
{
 return term_get_ecr(e);
}

void ptrbnd_inclusion_ind(ptrbnd e1, ptrbnd e2) 
{
 term_unify(ptrbnd_con_match,ptrbnd_occurs,e1,e2);
}

bool ptrbnd_eq(ptrbnd e1, ptrbnd e2)
{
 return term_eq(e1,e2);
}

int ptrbnd_cmp(const ptrbnd e1,const ptrbnd e2) 
{
 return term_get_stamp(e1) - term_get_stamp(e2);
}

void ptrbnd_inclusion_ind_contra(ptrbnd e1, ptrbnd e2) 
{
 term_unify(ptrbnd_con_match,ptrbnd_occurs,e2,e1);
}

void ptrbnd_unify(ptrbnd e1, ptrbnd e2) 
{
 banshee_clock_tick();
ptrbnd_unify_ind(e1,e2);
}

void ptrbnd_cunify(ptrbnd e1, ptrbnd e2) 
{
 banshee_clock_tick();
ptrbnd_cunify_ind(e1,e2);
}

void ptrbnd_cunify_ind(ptrbnd e1, ptrbnd e2) 
{
 term_cunify(ptrbnd_con_match,ptrbnd_occurs,e1,e2);
}

void ptrbnd_unify_ind(ptrbnd e1, ptrbnd e2) 
{
 term_unify(ptrbnd_con_match,ptrbnd_occurs,e1,e2);
}

ptrbnd atomic(void) 
{
return (gen_e)&atomic_;
}

bool ptrbnd_is_atomic(ptrbnd arg1) 
{
return ((gen_term)arg1)->type == atomic_.st;
}

bool ptrbnd_is_numelts(ptrbnd e)
{
 return ((gen_term)e)->type == 12;
}

ptrbnd numelts(intbound arg1) 
{
struct numelts_ *ret;
stamp s[2];
s[0] = NUMELTS_;
s[1] = intbound_get_stamp((gen_e)arg1);
if ((ret = (struct numelts_ *)term_hash_find(term_sort_hash,s,2)) == NULL)
{
ret = ralloc(term_sort_region,struct numelts_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(term_sort_hash,(gen_e)ret,s,2);
}
return (ptrbnd)ret;
}

struct numelts_decon numelts_decon(ptrbnd arg1) 
{
if (((gen_term)arg1)->type == NUMELTS_)
{
struct numelts_* c = (struct numelts_ *)arg1;
return (struct numelts_decon){c->f0};

}
else 
return (struct numelts_decon){NULL};
}

void ptrbnd_print(FILE* arg1,ptrbnd arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s",tv_get_name((term_var)ecr));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1,"%s",term_get_constant_name(ecr));
break;
case ATOMIC_:
fprintf(arg1,"atomic");
break;
case NUMELTS_:
{
fprintf(arg1,"numelts(");
intbound_print(arg1,((struct numelts_ *)ecr)->f0);
fprintf(arg1,")");

}
break;

default:
return ;
}

}

bool ptrbnd_occurs(term_var arg1,ptrbnd arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
return (term_get_stamp((gen_e)arg1) == term_get_stamp(ecr));
break;
case ATOMIC_:
return FALSE;
break;
case NUMELTS_:
{
struct numelts_ *con = (struct numelts_ *)arg2;
return ptrbnd_occurs(arg1,con->f0);

}
break;

default:
return FALSE;
}

}

void ptrbnd_con_match(gen_e arg1,gen_e arg2) 
{
switch(((gen_term)arg1)->type)
{
case ATOMIC_:
if (((gen_term)arg1)->type != ((gen_term)arg2)->type) handle_error(arg1,arg2,bek_cons_mismatch);
break;
case NUMELTS_:
switch(((gen_term)arg2)->type)
{
case NUMELTS_:
{
intbound_unify_ind(((struct numelts_ *)arg1)->f0,((struct numelts_ *)arg2)->f0);

}
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

stamp effect_get_stamp(gen_e arg1) 
{
return setif_get_stamp((gen_e)arg1);
}

bool effect_is_var(gen_e arg1) 
{
return setif_is_var((gen_e)arg1);
}

DEFINE_LIST(effect_list,gen_e);
effect effect_zero(void)
{
 return setif_zero();
}

effect effect_one(void)
{
 return setif_one();
}

effect effect_wild(void)
{
 return setif_wild();
}

effect effect_fresh(const char *name)
{
 return setif_fresh(name);
}

effect effect_fresh_small(const char *name)
{
 return setif_fresh_small(name);
}

effect effect_fresh_large(const char *name)
{
 return setif_fresh_large(name);
}

effect effect_union(effect_list exprs) 
{
 return setif_union(exprs);
}

effect effect_inter(effect_list exprs) 
{
 return setif_inter(exprs);
}

effect effect_constant(const char *name) 
{
 return setif_constant(name);
}

bool effect_eq(effect e1, effect e2) 
{
 return setif_eq(e1,e2);
}

int effect_cmp(const effect e1,const effect e2) 
{
 return setif_get_stamp(e1) - setif_get_stamp(e2);
}

bool effect_is_constant(effect e, const char *name) 
{
 if (setif_is_constant(e))
if (!name) return TRUE;
else return (! strcmp(name,setif_get_constant_name(e)));
else return FALSE;
}

effect_list effect_tlb(effect e) 
{
 return setif_tlb(e);
}

void effect_inclusion_ind(effect e1, effect e2) 
{
 setif_inclusion(effect_con_match,effect_res_proj,effect_print,e1,e2);
}

void effect_inclusion(effect e1, effect e2) 
{
 banshee_clock_tick();
effect_inclusion_ind(e1,e2);
}

void effect_inclusion_ind_contra(effect e1, effect e2) 
{
 setif_inclusion(effect_con_match,effect_res_proj,effect_print,e2,e1);
}

void effect_unify_ind(effect e1, effect e2) 
{
 setif_inclusion(effect_con_match,effect_res_proj,effect_print,e1,e2);
setif_inclusion(effect_con_match,effect_res_proj,effect_print,e2,e1);
}
void effect_unify(effect e1, effect e2) 
{
 banshee_clock_tick();
effect_unify_ind(e1,e2);
}
 
void effect_print(FILE* arg1,effect arg2) 
{
switch(((setif_term)arg2)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s::%d",sv_get_name((setif_var)arg2),sv_get_stamp((setif_var)arg2));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1,"%s",setif_get_constant_name(arg2));
break;
case UNION_TYPE:
{
gen_e_list list = setif_get_union(arg2);
gen_e_list_scanner scan;
gen_e temp;
gen_e_list_scan(list,&scan);
if (gen_e_list_next(&scan,&temp))
effect_print(arg1,temp);
while (gen_e_list_next(&scan,&temp))
{
fprintf(arg1," || ");
effect_print(arg1,temp);
}

}
break;
case INTER_TYPE:
{
gen_e_list list = setif_get_inter(arg2);
gen_e_list_scanner scan;
gen_e temp;
gen_e_list_scan(list,&scan);
if (gen_e_list_next(&scan,&temp))
effect_print(arg1,temp);
while (gen_e_list_next(&scan,&temp))
{
fprintf(arg1," && ");
effect_print(arg1,temp);
}

}
break;

default:
return ;
}

}

bool effect_res_proj(setif_var arg1,gen_e arg2) 
{
switch(((setif_term)arg2)->type)
{

default:
return FALSE;
}

return FALSE;
}

void effect_con_match(gen_e arg1,gen_e arg2) 
{
switch(((setif_term)arg1)->type)
{

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

stamp zeroterm_get_stamp(gen_e arg1) 
{
return term_get_stamp((gen_e)arg1);
}

bool zeroterm_is_var(gen_e arg1) 
{
return term_is_var((gen_e)arg1);
}

DEFINE_LIST(zeroterm_list,gen_e);

zeroterm zeroterm_zero(void)
{
 return term_zero();
}

zeroterm zeroterm_one(void)
{
 return term_one();
}

zeroterm zeroterm_wild(void)
{
 return term_wild();
}

zeroterm zeroterm_fresh(const char *name)
{
 return term_fresh(name);
}

zeroterm zeroterm_fresh_small(const char *name)
{
 return term_fresh_small(name);
}

zeroterm zeroterm_fresh_large(const char *name)
{
 return term_fresh_large(name);
}

zeroterm zeroterm_constant(const char *name) 
{
 return term_constant(name);
}

bool zeroterm_is_constant(zeroterm e, const char *name) 
{
 if (term_is_constant(e))
return (! strcmp(name,term_get_constant_name(e)));
else return FALSE;
}

zeroterm zeroterm_ecr(zeroterm e) 
{
 return term_get_ecr(e);
}

void zeroterm_inclusion_ind(zeroterm e1, zeroterm e2) 
{
 term_unify(zeroterm_con_match,zeroterm_occurs,e1,e2);
}

bool zeroterm_eq(zeroterm e1, zeroterm e2)
{
 return term_eq(e1,e2);
}

int zeroterm_cmp(const zeroterm e1,const zeroterm e2) 
{
 return term_get_stamp(e1) - term_get_stamp(e2);
}

void zeroterm_inclusion_ind_contra(zeroterm e1, zeroterm e2) 
{
 term_unify(zeroterm_con_match,zeroterm_occurs,e2,e1);
}

void zeroterm_unify(zeroterm e1, zeroterm e2) 
{
 banshee_clock_tick();
zeroterm_unify_ind(e1,e2);
}

void zeroterm_cunify(zeroterm e1, zeroterm e2) 
{
 banshee_clock_tick();
zeroterm_cunify_ind(e1,e2);
}

void zeroterm_cunify_ind(zeroterm e1, zeroterm e2) 
{
 term_cunify(zeroterm_con_match,zeroterm_occurs,e1,e2);
}

void zeroterm_unify_ind(zeroterm e1, zeroterm e2) 
{
 term_unify(zeroterm_con_match,zeroterm_occurs,e1,e2);
}

void zeroterm_print(FILE* arg1,zeroterm arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s",tv_get_name((term_var)ecr));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1,"%s",term_get_constant_name(ecr));
break;

default:
return ;
}

}

bool zeroterm_occurs(term_var arg1,zeroterm arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
return (term_get_stamp((gen_e)arg1) == term_get_stamp(ecr));
break;

default:
return FALSE;
}

}

void zeroterm_con_match(gen_e arg1,gen_e arg2) 
{
switch(((gen_term)arg1)->type)
{

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

stamp intlit_get_stamp(gen_e arg1) 
{
return term_get_stamp((gen_e)arg1);
}

bool intlit_is_var(gen_e arg1) 
{
return term_is_var((gen_e)arg1);
}

DEFINE_LIST(intlit_list,gen_e);

intlit intlit_zero(void)
{
 return term_zero();
}

intlit intlit_one(void)
{
 return term_one();
}

intlit intlit_wild(void)
{
 return term_wild();
}

intlit intlit_fresh(const char *name)
{
 return term_fresh(name);
}

intlit intlit_fresh_small(const char *name)
{
 return term_fresh_small(name);
}

intlit intlit_fresh_large(const char *name)
{
 return term_fresh_large(name);
}

intlit intlit_constant(const char *name) 
{
 return term_constant(name);
}

bool intlit_is_constant(intlit e, const char *name) 
{
 if (term_is_constant(e))
return (! strcmp(name,term_get_constant_name(e)));
else return FALSE;
}

intlit intlit_ecr(intlit e) 
{
 return term_get_ecr(e);
}

void intlit_inclusion_ind(intlit e1, intlit e2) 
{
 term_unify(intlit_con_match,intlit_occurs,e1,e2);
}

bool intlit_eq(intlit e1, intlit e2)
{
 return term_eq(e1,e2);
}

int intlit_cmp(const intlit e1,const intlit e2) 
{
 return term_get_stamp(e1) - term_get_stamp(e2);
}

void intlit_inclusion_ind_contra(intlit e1, intlit e2) 
{
 term_unify(intlit_con_match,intlit_occurs,e2,e1);
}

void intlit_unify(intlit e1, intlit e2) 
{
 banshee_clock_tick();
intlit_unify_ind(e1,e2);
}

void intlit_cunify(intlit e1, intlit e2) 
{
 banshee_clock_tick();
intlit_cunify_ind(e1,e2);
}

void intlit_cunify_ind(intlit e1, intlit e2) 
{
 term_cunify(intlit_con_match,intlit_occurs,e1,e2);
}

void intlit_unify_ind(intlit e1, intlit e2) 
{
 term_unify(intlit_con_match,intlit_occurs,e1,e2);
}

void intlit_print(FILE* arg1,intlit arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s",tv_get_name((term_var)ecr));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1,"%s",term_get_constant_name(ecr));
break;

default:
return ;
}

}

bool intlit_occurs(term_var arg1,intlit arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
return (term_get_stamp((gen_e)arg1) == term_get_stamp(ecr));
break;

default:
return FALSE;
}

}

void intlit_con_match(gen_e arg1,gen_e arg2) 
{
switch(((gen_term)arg1)->type)
{

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

stamp intbound_get_stamp(gen_e arg1) 
{
return term_get_stamp((gen_e)arg1);
}

bool intbound_is_var(gen_e arg1) 
{
return term_is_var((gen_e)arg1);
}

DEFINE_LIST(intbound_list,gen_e);

intbound intbound_zero(void)
{
 return term_zero();
}

intbound intbound_one(void)
{
 return term_one();
}

intbound intbound_wild(void)
{
 return term_wild();
}

intbound intbound_fresh(const char *name)
{
 return term_fresh(name);
}

intbound intbound_fresh_small(const char *name)
{
 return term_fresh_small(name);
}

intbound intbound_fresh_large(const char *name)
{
 return term_fresh_large(name);
}

intbound intbound_constant(const char *name) 
{
 return term_constant(name);
}

bool intbound_is_constant(intbound e, const char *name) 
{
 if (term_is_constant(e))
return (! strcmp(name,term_get_constant_name(e)));
else return FALSE;
}

intbound intbound_ecr(intbound e) 
{
 return term_get_ecr(e);
}

void intbound_inclusion_ind(intbound e1, intbound e2) 
{
 term_unify(intbound_con_match,intbound_occurs,e1,e2);
}

bool intbound_eq(intbound e1, intbound e2)
{
 return term_eq(e1,e2);
}

int intbound_cmp(const intbound e1,const intbound e2) 
{
 return term_get_stamp(e1) - term_get_stamp(e2);
}

void intbound_inclusion_ind_contra(intbound e1, intbound e2) 
{
 term_unify(intbound_con_match,intbound_occurs,e2,e1);
}

void intbound_unify(intbound e1, intbound e2) 
{
 banshee_clock_tick();
intbound_unify_ind(e1,e2);
}

void intbound_cunify(intbound e1, intbound e2) 
{
 banshee_clock_tick();
intbound_cunify_ind(e1,e2);
}

void intbound_cunify_ind(intbound e1, intbound e2) 
{
 term_cunify(intbound_con_match,intbound_occurs,e1,e2);
}

void intbound_unify_ind(intbound e1, intbound e2) 
{
 term_unify(intbound_con_match,intbound_occurs,e1,e2);
}

bool intbound_is_eq(intbound e)
{
 return ((gen_term)e)->type == 13;
}

intbound eq(intlit arg1) 
{
struct eq_ *ret;
stamp s[2];
s[0] = EQ_;
s[1] = intlit_get_stamp((gen_e)arg1);
if ((ret = (struct eq_ *)term_hash_find(term_sort_hash,s,2)) == NULL)
{
ret = ralloc(term_sort_region,struct eq_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(term_sort_hash,(gen_e)ret,s,2);
}
return (intbound)ret;
}

struct eq_decon eq_decon(intbound arg1) 
{
if (((gen_term)arg1)->type == EQ_)
{
struct eq_* c = (struct eq_ *)arg1;
return (struct eq_decon){c->f0};

}
else 
return (struct eq_decon){NULL};
}

bool intbound_is_geq(intbound e)
{
 return ((gen_term)e)->type == 14;
}

intbound geq(intlit arg1) 
{
struct geq_ *ret;
stamp s[2];
s[0] = GEQ_;
s[1] = intlit_get_stamp((gen_e)arg1);
if ((ret = (struct geq_ *)term_hash_find(term_sort_hash,s,2)) == NULL)
{
ret = ralloc(term_sort_region,struct geq_);
ret->type = s[0];
ret->st = stamp_fresh();
ret->f0 = arg1;
term_hash_insert(term_sort_hash,(gen_e)ret,s,2);
}
return (intbound)ret;
}

struct geq_decon geq_decon(intbound arg1) 
{
if (((gen_term)arg1)->type == GEQ_)
{
struct geq_* c = (struct geq_ *)arg1;
return (struct geq_decon){c->f0};

}
else 
return (struct geq_decon){NULL};
}

void intbound_print(FILE* arg1,intbound arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
fprintf(arg1,"%s",tv_get_name((term_var)ecr));
break;
case ZERO_TYPE:
fprintf(arg1,"0");
break;
case ONE_TYPE:
fprintf(arg1,"1");
break;
case CONSTANT_TYPE:
fprintf(arg1,"%s",term_get_constant_name(ecr));
break;
case EQ_:
{
fprintf(arg1,"eq(");
intlit_print(arg1,((struct eq_ *)ecr)->f0);
fprintf(arg1,")");

}
break;
case GEQ_:
{
fprintf(arg1,"geq(");
intlit_print(arg1,((struct geq_ *)ecr)->f0);
fprintf(arg1,")");

}
break;

default:
return ;
}

}

bool intbound_occurs(term_var arg1,intbound arg2) 
{
gen_e ecr = term_get_ecr(arg2);
switch(((gen_term)ecr)->type)
{
case VAR_TYPE:
return (term_get_stamp((gen_e)arg1) == term_get_stamp(ecr));
break;
case EQ_:
{
struct eq_ *con = (struct eq_ *)arg2;
return intbound_occurs(arg1,con->f0);

}
break;
case GEQ_:
{
struct geq_ *con = (struct geq_ *)arg2;
return intbound_occurs(arg1,con->f0);

}
break;

default:
return FALSE;
}

}

void intbound_con_match(gen_e arg1,gen_e arg2) 
{
switch(((gen_term)arg1)->type)
{
case EQ_:
switch(((gen_term)arg2)->type)
{
case EQ_:
{
intlit_unify_ind(((struct eq_ *)arg1)->f0,((struct eq_ *)arg2)->f0);

}
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;
case GEQ_:
switch(((gen_term)arg2)->type)
{
case GEQ_:
{
intlit_unify_ind(((struct geq_ *)arg1)->f0,((struct geq_ *)arg2)->f0);

}
break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

break;

default:
handle_error(arg1,arg2,bek_cons_mismatch);
}

return;
}

void cycinf_init(void) 
{
engine_init();
term_init();
setif_init();
term_init();
term_init();
term_init();
}

void cycinf_reset(void) 
{
engine_reset();
term_reset();
setif_reset();
term_reset();
term_reset();
term_reset();
}

void cycinf_stats(FILE * arg1) 
{
engine_stats(arg1);
}

void cycinf_print_graph(FILE * arg1) 
{
print_constraint_graphs(arg1);
}

void cycinf_dump_graph()
{
print_constraint_graphs(stdout);
}

void cycinf_serialize(FILE * arg1,hash_table * arg2,unsigned long arg3) 
{
return;
}

hash_table * cycinf_deserialize(FILE * arg1) 
{
return NULL;
}

void cycinf_region_serialize(FILE * arg1) 
{
return;
}

void cycinf_region_deserialize(translation arg1,FILE * arg2) 
{
return;
}

